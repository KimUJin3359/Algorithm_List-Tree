# List, Tree

### 리스트
- 순서를 가진 데이터의 집합을 가리키는 추상 자료형
- 동일한 데이터를 가지고 있어도 상관없음
- 순차 리스트
  - 배열을 기반으로 구현된 리스트
  - 문제점
    - 자료의 삽입/삭제 연산 과정에서 연속적인 메모리 배열을 위해 원소들을 이동시키는 작업이 필요
    - 원소의 개수가 많고 삽입/삭제가 빈번하게 일어나면 소요되는 시간이 증가
    - 크기가 고정적
- 연결 리스트
  - 메모리의 동적할당을 기반으로 구현된 리스트
  - 특성
    - 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않음
- 주요 함수
  - addtoFirst() : 리스트의 앞쪽에 원소를 추가
  - addtoLast() : 리스트의 뒤쪽에 원소를 추가
  - add() : 리스트의 특정 위치에 원소를 추가
  - delete() : 리스트의 특정 위치에 있는 원소를 삭제
  - get() : 리스트의 특정 위치에 있는 원소를 리턴

### 연결리스트(Linked List)
- 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않음
- 개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조를 구성
- 링크를 통해 원소에 접근
- 자료구조의 크기를 동적으로 조정할 수 있어, 메모리의 효율적인 사용이 가능
- 구조
  - 노드
    - 하나의 원소에 필요한 데이터를 갖고 있는 자료단위
    - 데이터 필드와 링크 필드로 구성
  - 헤드
    - 리스트의 처음 노드를 가리키는 레퍼런스
- 단순 연결 리스트
  - 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조
- 이중 연결 리스트
  - 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
  - 두 개의 링크 필드와 한 개의 데이터 필드로 구성
  
### 정렬
- 삽입 정렬(Insertion Sort)
  - 도서관 사서가 책을 정렬할 때, 일반적으로 사용되는 방식
  - 정렬 과정
    - 정렬할 자료를 두 개의 부분집합 S(정렬된 앞 부분의 원소들)와 U(아직 정렬되지 않은 나머지 원소들)로 가정
    - 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬되어 있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입
  - O(n^2)
- 병합 정렬(Merge Sort)
  - 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
  - 분할 정복 알고리즘 활용
    - 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
    - top-down 방식
  - 정렬 과정
    - 분할 단계 : 전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업
    - 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합
  - O(nlogn)



