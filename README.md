# List, Tree

### 리스트
- 순서를 가진 데이터의 집합을 가리키는 추상 자료형
- 동일한 데이터를 가지고 있어도 상관없음
- 순차 리스트
  - 배열을 기반으로 구현된 리스트
  - 문제점
    - 자료의 삽입/삭제 연산 과정에서 연속적인 메모리 배열을 위해 원소들을 이동시키는 작업이 필요
    - 원소의 개수가 많고 삽입/삭제가 빈번하게 일어나면 소요되는 시간이 증가
    - 크기가 고정적
- 연결 리스트
  - 메모리의 동적할당을 기반으로 구현된 리스트
  - 특성
    - 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않음
- 주요 함수
  - addtoFirst() : 리스트의 앞쪽에 원소를 추가
  - addtoLast() : 리스트의 뒤쪽에 원소를 추가
  - add() : 리스트의 특정 위치에 원소를 추가
  - delete() : 리스트의 특정 위치에 있는 원소를 삭제
  - get() : 리스트의 특정 위치에 있는 원소를 리턴

### 연결리스트(Linked List)
- 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않음
- 개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조를 구성
- 링크를 통해 원소에 접근
- 자료구조의 크기를 동적으로 조정할 수 있어, 메모리의 효율적인 사용이 가능
- 구조
  - 노드
    - 하나의 원소에 필요한 데이터를 갖고 있는 자료단위
    - 데이터 필드와 링크 필드로 구성
  - 헤드
    - 리스트의 처음 노드를 가리키는 레퍼런스
- 단순 연결 리스트
  - 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조
- 이중 연결 리스트
  - 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
  - 두 개의 링크 필드와 한 개의 데이터 필드로 구성
  
### 정렬
- 삽입 정렬(Insertion Sort)
  - 도서관 사서가 책을 정렬할 때, 일반적으로 사용되는 방식
  - 정렬 과정
    - 정렬할 자료를 두 개의 부분집합 S(정렬된 앞 부분의 원소들)와 U(아직 정렬되지 않은 나머지 원소들)로 가정
    - 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬되어 있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입
  - O(n^2)
- 병합 정렬(Merge Sort)
  - 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
  - 분할 정복 알고리즘 활용
    - 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
    - top-down 방식
  - 정렬 과정
    - 분할 단계 : 전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업
    - 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합
  - O(nlogn)

### 트리
- 비선형 구조
- 원소들 간에 1 : n 관계를 가지는 자료구조
- 한 개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족
  - 노드 중 최상위 노드를 root라 함
  - 나머지 노드들은 n(>=0)개의 분리집합 T1, ..., TN(subtree)으로 분리될 수 있음
- 용어정리
  - node : 트리의 원소
  - edge : 노드를 연결하는 선
  - root node : 트리의 시작 노드
  - silbing node(형제 노드) : 같은 부모 노드의 자식 노드들
  - 조상 노드 : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
  - subtree : 부모 노드와 연결된 간선을 끊어쓸 때 생성되는 트리
  - 자손 노드 : 서브 트리에 있는 하위 레벨의 노드들
  - degree(차수)
    - 노드의 차수 : 노드에 연결된 자식 노드의 수
    - 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값
    - leaf node(단말 노드) : 차수가 0인 노드
  - 높이
    - 노드의 높이(레벨) : 루트에서 노드에 이르는 간선의 수
    - 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값
    
### 이진트리
- 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리
- 특성
  - 레벨 i에서의 노드의 최대 개수는 2^i개
  - 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 (h + 1)개(좌/우 편향 트리)가 되며, 최대 개수는 (2^(h + 1) - 1)개(-1은 루트노드로 인하여 발생)
- 포화 이진 트리
  - 모든 레벨에 노드가 포화상태(2^(h + 1) - 1)로 차 있는 이진 트리
- 완전 이진 트리
  - 높이가 h이고 노드 수가 n개일 때, 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
- 편향 이진 트리
  - 높이 h에 대한 최수 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
  
### 순회
- 트리의 각 노드를 중복되지 않게 전부 방문하는 것
- 전위 순회(preorder) : V - L - R
- 중위 순회(inorder) : L - V - R
- 후위 순회(postorder) : L - R - V

### 수식트리(수식 이진 트리)
- 수식을 표현하는 이진 트리
- 연산자는 루트 노드이거나 가지 노드
- 피연산자는 모두 leaf 노드

### 이진탐색트리
- 탐색작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 서로 다른 유일한 키를 가짐
- key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
- 왼쪽, 오른쪽 서브트리도 이진 탐색 트리
- 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있음
- 탐색 연산
  - key value = root node key : 탐색 연산 성공
  - key value < root node key : 루트 노드의 왼쪽 서브트리에 대해 탐색연산
  - key value > root node key : 루트 노드의 오른쪽 서브트리에 대해 탐색연산
- 성능
  - 탐색(search), 삽입(insert), 삭제(delete) 시간은 트리의 높이(O(h))
  - 이진 트리가 균형적으로 생성되어 있는 경우(O(log n))
  - 한 쪽으로 치우친 경사 이진트리 경우(O(n))
  
### 힙
- 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- 최대 힙(max heap)
  - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  - (부모 노드의 키 값 > 자식 노드의 키 값)
  - 루트 노드 : 키 값이 가장 큰 노드
- 최소 힙(min heap)
  - 최대 힙과 반대

#### 관련 문제
[1.Calculator](https://github.com/KimUJin3359/List-Tree/tree/master/Calculator)
- 사칙연산(+, -, \*, /)와 양의 정수로만 구성된 임의의 이진트리가 주어질 때, 이를 계산한 결과를 출력하는 문제
- 까다로운 점
  - 처음 입력받는 것이 연산자냐 숫자냐에 따라 추가 입력 여부가 달라짐
    - space, new line을 기준으로 split해서 사용
  - ascii 값 ' + ', ' - ', ' \* ', ' / '과 중복된 숫자가 나올 때 +와 43을 구분하는 방법
    - input 배열을 3칸을 만들어 입력 받은 뒤의 숫자가 더 존재하는지를 판단해줌으로써 판별

[2.Calculator2](https://github.com/KimUJin3359/List-Tree/tree/master/Calculator2)
- 사칙연산(+, -, \*, /)와 양의 정수로만 구성된 임의의 이진트리가 주어질 때, 이 식의 유효성을 검사하는 문제
- 유효성을 검사하는 문제이므로 0으로 나누느 경우는 고려하지 않음
- 접근 방법
  - 위의 계산기 코드를 바탕으로, 모든 계산을 끝낸 후 방문하지 않은 node가 있는지 없는지를 판단해줌

[3.Heapsort](https://github.com/KimUJin3359/List-Tree/tree/master/Heapsort)
- N개의 수가 주어졌을 떄, 이를 오름차순으로 정렬하는 문제
- 접근 방법
  - 기본적인 bubble sort, selection sort는 O(n ^ 2)의 시간복잡도를 가짐
    - Time out
  - priority queue를 구성하여, Heap Sort로 구현
  - enqueue() : 해당 번째의 node에 삽입하여 조상 노드들과 크기를 비교하며 swap
  - dequeue() : root를 반환 후, 맨 마지막에 존재하는 노드의 데이터를 root로 가져와 left, right 중 값이 더 작은 node와 swap

[4.Inorder](https://github.com/KimUJin3359/List-Tree/tree/master/Inorder)
- 특정 단어(또는 문장)를 트리 형태로 구성한 것을 inorder 형식으로 순회하여 각 노드를 읽는 문제
- 해당 정점에 대한 정보는 해당 정점의 알파벳, 해당 정점의 왼쪽 자식, 오른쪽 자식의 정점번호가 차례대로 주어짐
- 까다로운 점
  - 입력받는 노드의 자식 유무에 따라 추가 입력 여부가 달라짐
    - space, new line을 기준으로 split해서 사용
  - 입력받는 값의 문자열, 숫자 처리 방법
    - 숫자를 입력받으면 기존의 atoi와 같은 형태로 작동, 문자를 받으면 값을 그대로 반환
  - 해당 node 번호에 대한 문자 값을 나중에 입력받음
    - ex) 1 A 2 3
    - 2번 3번 노드는 이미 선언되고 난 후에 그에 해당하는 문자 값을 입력 받음
    - set_data 함수 구현 (해당 num에 해당하는 node를 찾아 data를 set)
- 지금 생각하니 없어도 되는 부분
  - 추가 입력되는 첫번째 노드는 무조건 왼쪽 노드이기 때문에 tree에 add_left, add_right를 따로 구현할 필요가 없었음
    
[5.Tree](https://github.com/KimUJin3359/List-Tree/tree/master/Tree)
- 트리를 구성하여 inorder, preorder, postorder 및 levelorder에 따른 노드 값 출력

[6.Zombie](https://github.com/KimUJin3359/List-Tree/tree/master/Zombie)
- 보안관의 위치와 좀비의 위치가 주어질 때, 최소 시간으로 좀비에게 접근할 때 걸리는 시간을 구하는 문제
- 접근 방법
  - 이동 가능한 경우를 큰 값부터 정렬
  - BFS를 통해 만족하는 경우를 찾으며 찾을 경우 종료



